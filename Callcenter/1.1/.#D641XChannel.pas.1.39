unit D641XChannel;

interface

uses
  Classes, Windows, SysUtils, LightweightCTI;

type
  THackChannel = class(TAbstractChannel);

  TTrunkChannel = class(TAbstractChannel)
  private
    function PlayPromptStr(const Afilelist: string):TPlayMessageResult;
    function PlayFileDetect(const AllowBreak: Boolean):TPlayMessageResult;
    procedure PlayFileStop;
    procedure PlayFileStop2(AchannelID: Integer);
    function GetDTMFCode:string;
    function InnerSchedule(AserverType: string): Integer;
    function PlayPromptStr2(AchannelID: Integer; Afilelist: string):TPlayMessageResult;
    function PlayFileDetect2(const AllowBreak: Boolean; AchannelID: Integer):TPlayMessageResult;
  protected
  public
    Fpcm,Fchn : integer;
    function ConvertDtmfToStr(Acode: Integer): string;
    function RingDetect(const Atimes: Integer = 1): Boolean; override; // 振铃检测
    procedure OffHook; override; // 摘机
    function OffHookDetect: Boolean; override; // 内线摘机检测
    procedure HangUp; override; // 被叫挂机
    function HangUpDetect: Boolean; override; // 被叫挂机检测
    procedure ResetChannel; override; // 重置通道
    function Schedule(AserverType: string; Afilelist: string): Integer; override;//获取最少接电话的坐席号

    // 主叫或被叫函数
    function GetCallerNumber: string; override; // 获取主叫号码
    function GetCalleeNumber: string; override; // 获取被叫号码

    // 拨号及放音函数
    function Dial(const Adialnum: string; const APrefixnum: string = ''):
      TSignalType; override; // 向外拨号
    function DtmfHit: Boolean; override; // 按键检测
    function GetDTMF(const Alength: Integer; Asuffix: string = '#';
      const Atimeout: Integer = 0): string; override; // 取DTMF号码
    procedure ClearDTMF; override; // 清空DTMF缓存
    function PlayMessage(const Atxt: string; const AllowBreak: Boolean = True):
      TPlayMessageResult; override; // 播放一段文字
    function PlayNumber(const Atxt: string; const AllowBreak: Boolean = True;
      const APlayType: TPlayNumberType = pntMessage): TPlayMessageResult;
      override; // 播放数字
    procedure PlayVoice(AvoiceType: integer);override;
    function PlayFile(const Afilelist, AfileExt: string;
      const AllowBreak: Boolean = True): TPlayMessageResult; override; // 播放语音文件   
    function PlayFileToTrunkAndUser(const Afilelist, AfileExt: string;
      const AllowBreak: Boolean = True; AchannelID: Integer = -1): TPlayMessageResult; override; // 给双方播放音乐
    function PlayToFile(const Atxt: string; const Afilename: string;
      const AVoiceResource: TVoiceResourceType = vrtStandard): Boolean;
      override; // 播放到文件
    function SendMessage(const Atxt: string): Boolean; override; // 发送信息

    // 录音函数
    function RecordFile(const Afilename: string; ALengthTimes: Integer = 60;
      AllowBreak: Boolean = True): TRecordFileResult; override; // 录音

    // 通道连通函数
    function LinkTo(const AChannelID: Integer = -1;
      const AChannelType: TChannelType = ctUser): Integer; override; // 连接到某一通道
    function UnLink(const AChannelID: Integer = -1;
      const AChannelType: TChannelType = ctUser): Integer; override; // 断开与某通道的连接
    function UnLinkAll: Boolean; override; // 断开与所有通道的连接
    function ListenTo(const AChannelID: Integer): Integer; override; // 监听某一通道
    procedure RecordFile_stop;
  end;
  
  TUserChannel = class(TAbstractChannel)
  private            
    function PlayPromptStr(const Afilelist: string):TPlayMessageResult;       
    function PlayFileDetect(const AllowBreak: Boolean):TPlayMessageResult;
    procedure PlayFileStop;
    function GetDTMFCode:string;
  protected
  public
    localphone : string;//= '037163329079';
    FserverNum : integer;
    function ConvertDtmfToStr(Acode: Integer): string;       
    function RingDetect(const Atimes: Integer = 1): Boolean; override; // 振铃检测
    procedure OffHook; override; // 摘机
    function OffHookDetect: Boolean; override; // 内线摘机检测
    procedure HangUp; override; // 被叫挂机
    function HangUpDetect: Boolean; override; // 被叫挂机检测
    procedure ResetChannel; override; // 重置通道

    // 主叫或被叫函数
    function GetCallerNumber: string; override; // 获取主叫号码
    function GetCalleeNumber: string; override; // 获取被叫号码

    // 拨号及放音函数
    function Dial(const Adialnum: string; const APrefixnum: string = ''):
      TSignalType; override; // 向外拨号
    function DtmfHit: Boolean; override; // 按键检测
    function GetDTMF(const Alength: Integer; Asuffix: string = '#';
      const Atimeout: Integer = 0): string; override; // 取DTMF号码
    procedure ClearDTMF; override; // 清空DTMF缓存
    function PlayMessage(const Atxt: string; const AllowBreak: Boolean = True):
      TPlayMessageResult; override; // 播放一段文字
    function PlayNumber(const Atxt: string; const AllowBreak: Boolean = True;
      const APlayType: TPlayNumberType = pntMessage): TPlayMessageResult;
      override; // 播放数字
    procedure PlayVoice(AvoiceType: integer);override;
    function PlayFile(const Afilelist, AfileExt: string;
      const AllowBreak: Boolean = True): TPlayMessageResult; override; // 播放语音文件
    function PlayToFile(const Atxt: string; const Afilename: string;
      const AVoiceResource: TVoiceResourceType = vrtStandard): Boolean;
      override; // 播放到文件
    function SendMessage(const Atxt: string): Boolean; override; // 发送信息

    // 录音函数
    function RecordFile(const Afilename: string; ALengthTimes: Integer = 60;
      AllowBreak: Boolean = True): TRecordFileResult; override; // 录音

    // 通道连通函数
    function LinkTo(const AChannelID: Integer = -1;
      const AChannelType: TChannelType = ctUser): Integer; override; // 连接到某一通道
    function UnLink(const AChannelID: Integer = -1;
      const AChannelType: TChannelType = ctUser): Integer; override; // 断开与某通道的连接
    function UnLinkAll: Boolean; override; // 断开与所有通道的连接
    function ListenTo(const AChannelID: Integer): Integer; override; // 监听某一通道  
    function Schedule(AserverType: string;Afilelist: string): Integer;override;//获取最少接电话的坐席号
  end;
implementation

uses
  GlobalConstants,HTJS_Tce132,HTJS_ISDNDLL, Math;

const
  D641XCS = 'D641XCS'; // 临界区字符串

procedure TTrunkChannel.ClearDTMF;
begin
  inherited;  FDtmf := '';
  FChannelManager.EnterCS(D641XCS);
  try
    {$IFDEF CTI_DEBUG} ChannelLog('DEBUG# 清除按键缓冲区中的键按信息'); {$ENDIF}
    HTJS_Trk_InitDtmfBuf (ChannelID);
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

{-------------------------------------------------------------------------------
  Procedure: TTrunkChannel.ConvertDtmfToStr
  Author:    hxn
  DateTime:  2007.08.30
  Arguments: Acode: Integer
  Result:    string
  Popose:    将用户拨入的电话按键转换成字符串
-------------------------------------------------------------------------------}
function TTrunkChannel.ConvertDtmfToStr(Acode: Integer): string;
begin
  case Acode of
    10 : Result := '0';
    11 : Result := '*';
    12 : Result := '#';
    13 : Result := 'A';
    14 : Result := 'B';
    15 : Result := 'C';
     0 : Result := 'D';
    1..9 : Result := IntToStr(Acode);
    -1 : Result := '~';
  end;
end;

function TTrunkChannel.Dial(const Adialnum,
  APrefixnum: string): TSignalType;
var AResult: Integer;
begin  Result := stNoResult;
  {$IFDEF CTI_DEBUG}  ChannelLog('DEBUG# 准备拨号……'); {$ENDIF}
  if Assigned(FOnCallOut) then FOnCallOut(Self, iif(APrefixnum <> '', APrefixnum + ',' + Adialnum, Adialnum));
  //ResetChannel;
  {$IFDEF CTI_DEBUG} ChannelLog('系统提机开始拨号，拨出电话号码为：' + Adialnum); {$ENDIF}

  Status := csDial; ChannelLog('系统开发拨号，呼出号码为：' + Adialnum);
  FChannelManager.EnterCS(D641XCS);
  try
    //AResult :=  HTJS_ISDN_Callout(Fpcm,Fchn,PChar(Adialnum), PChar(APrefixnum),PChar(GClocalphone), '');
    AResult :=  HTJS_ISDN_Callout(Fpcm,Fchn,PChar(Adialnum), '',PChar(GClocalphone), '');
    if AResult = 1 then begin ChannelLog('等待对方摘机');  Status := csRing; end
    else begin {$IFDEF CTI_DEBUG}  Log('开始检查拨号返回结果……'); {$ENDIF}
      Status := csWaitingSignal;
      AResult:=HTJS_ISDN_GetDisconnectReason(Fpcm,Fchn);
      case DISCONNECT_REASON(AResult) of
        RSN_UNKNOW_REASON : ChannelLog('原因未知');
        RSN_UNALLOC_NUMBER : ChannelLog('空号');
        RSN_NORMAL_DISCONNECT : ChannelLog('正常的呼叫清除');
        RSN_USER_BUSY : ChannelLog('用户忙');
        RSN_NO_RESPOND : ChannelLog('无响应');
        RSN_NO_ANSWER : ChannelLog('无用户应答');
        RSN_REFUSR_CALL : ChannelLog('呼叫拒绝');
        RSN_NUMBER_ERROR : ChannelLog('号码不全');
        RSN_TIMEOUT : ChannelLog('超时');
        RSN_DCHANNEL_DOWN : ChannelLog('链路中断');
        RSN_BCHANNEL_UNAVIABLE : ChannelLog('通道不可用');
        RSN_UNAVIABLE_CIRCULT : ChannelLog('无可用通路');
        RSN_UNSVIABLE_MSG : ChannelLog('无效的消息');
      end;
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.DtmfHit: Boolean;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    Result := HTJS_Trk_GetReciveDtmfNum(ChannelID)>0;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.GetCalleeNumber: string;
begin
  Result := '400 811 0006';
end;

function TTrunkChannel.GetCallerNumber: string;
var
  AcallerID: PAnsiChar;   Atmp: string;
begin
  {$IFDEF CTI_DEBUG}   ChannelLog('开始获取主叫号码……');  {$ENDIF}
  Result := ''; AcallerID := StrAlloc(32 * SizeOf(Char));
  FChannelManager.EnterCS(D641XCS);
  try
    HTJS_ISDN_GetCallerNumber(Fpcm,Fchn,AcallerID);//获取主叫号码
    Atmp := AcallerID;
    HTJS_ISDN_GetCallerSubAddr(Fpcm,Fchn,AcallerID);//获取主叫子地址号码
    Atmp := Atmp + AcallerID;
    FCallNumber := Atmp;  Result := Atmp; ChannelLog('获取主叫号码为：' + Result);
    if Assigned(FOnCallIn) then FOnCallIn(Self, Result);
  finally
    StrDispose(AcallerID);
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.GetDTMFCode:string;
begin
  FChannelManager.EnterCS(D641XCS);
  try Result := 'z';
    if (HTJS_ISDN_GetChnState(Fpcm,Fchn) <> CH_WAIT_APP_FREE) and (HTJS_ISDN_GetChnState(Fpcm,Fchn) <> CH_WAIT_RELEASE) then
      Result := HTJS_Trk_GetDtmfCode(ChannelID);
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.GetDTMF(const Alength: Integer; Asuffix: string;
  const Atimeout: Integer): string;
var
  K: Integer; T: Cardinal;
begin
  Result := ''; K := iif(Atimeout = 0, TimeOut, Atimeout); // 设置按键的超时值
  Status  := csGetDtmf; T := GetTickCount;
  {$IFDEF CTI_DEBUG} Log('准备获取对方按键……'); {$ENDIF}
  while (length(FDtmf)<Alength) and (GetTickCount - T < Cardinal(K * GCTimeOutRate)) do begin
    FDtmf := GetDTMFCode;
    if FDtmf = 'z' then break;
  end;
  if  FDtmf <> 'z' then
    if length(FDtmf)<Alength then   FDtmf := ''
    else FDtmf := copy(FDtmf,1,Alength);
  Result := FDtmf; ChannelLog('获取对方按键完成，对方按键为：' + FDtmf);
  ClearDTMF;
end;

procedure TTrunkChannel.HangUp;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    HTJS_ISDN_SetChnState(Fpcm,Fchn,CH_SET_DISCONNECT,0);
    HTJS_ISDN_SetChnState(Fpcm,Fchn,CH_SET_FREE,0);//设置通道状态为空闲
  finally
    FChannelManager.LeaveCS(D641XCS);
    Sleep(500);
  end;
end;

function TTrunkChannel.HangUpDetect: Boolean;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    //Result := HTJS_ISDN_GetChnState(Fpcm,Fchn) = CH_SET_DISCONNECT
    Result := (HTJS_ISDN_GetChnState(Fpcm,Fchn) = CH_WAIT_APP_FREE) or (HTJS_ISDN_GetChnState(Fpcm,Fchn) = CH_WAIT_RELEASE);
    if Result then FLinkToChannel := -1;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.Schedule(AserverType: string;Afilelist: string): Integer;
var PlayResult : TPlayMessageResult;
begin  Result := -1;
  Result := InnerSchedule(AserverType);
  if Result <> -1 then exit;
  PlayResult := PlayPromptStr(Afilelist);
  if PlayResult <> pmrHangup then
    while  (PlayFileDetect(false) = pmrPlaying) do begin
     Result := InnerSchedule(AserverType);
     if Result = -1 then sleep(10) else break;
    end;
  PlayFileStop;
end;
function TTrunkChannel.InnerSchedule(AserverType: string): Integer;//获取最少接电话的坐席号
var
  i,AchannelID,max:integer;  Achnl: TAbstractChannel;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    AchannelID := -1;
    max := 1000;
    for i:= 0 to ChannelManager.userChannels.Count-1 do
      begin
        Achnl := TAbstractChannel(ChannelManager.userChannels[i]);
        if (Achnl.Status = csFree) and (pos(AserverType+',',Achnl.FserverType+',') > 0) and (Achnl.FserverNum < max) then
          begin
            AchannelID := i;
            max := Achnl.FserverNum;
          end;
      end;

    if AchannelID <> -1 then
      begin
        TAbstractChannel(ChannelManager.userChannels[AchannelID]).Status := csLink;
        TAbstractChannel(ChannelManager.userChannels[AchannelID]).Terminate;
      end;

    Result := AchannelID;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.LinkTo(const AChannelID: Integer; const AChannelType: TChannelType): Integer;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    Result := -1;
    if (AChannelType = ctUser) and HTJS_Exg_SetLinkTrunkAndUser(ChannelID,AChannelID) then begin
      Result := AChannelID; FLinkToChannel := AChannelID;
    end;
    if (AChannelType = ctTrunk) and HTJS_Exg_SetLinkTrunkAndUser(AChannelID,ChannelID) then begin
      Result := AChannelID; FLinkToChannel := AChannelID;
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.ListenTo(const AChannelID: Integer): Integer;
begin
    result :=0;
end;

procedure TTrunkChannel.OffHook;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    htjs_isdn_setchnstate(Fpcm,Fchn,ch_set_connect,0);
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.OffHookDetect: Boolean;
begin
  FChannelManager.EnterCS(D641XCS);   Result := false;
  try  {$IFDEF CTI_DEBUG} ChannelLog('进行挂机检测'); {$ENDIF}
    if Status = csWaitingSignal then
      begin
        HTJS_ISDN_SetChnState(Fpcm,fchn,CH_SET_FREE,0);
        Status := csFree;
      end
    else begin
      Result := HTJS_ISDN_GetChnState(Fpcm,fchn) = ch_connect;
      //Result := DJISDN_GetCalloutResult(Fpcm,Fchn) = C_USER_OFFHOOK;
      if Result then begin Status := csConnect;ChannelLog('对方摘机'); end;
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.PlayPromptStr(const Afilelist: string):TPlayMessageResult;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    if Status = csHangup then Result := pmrHangup
    else begin
      Status := csPlaying; Result := pmrPlaying;
      HTJS_Trk_PlayPromptStr(ChannelID,Afilelist);
      HTJS_Trk_InitDtmfBuf (ChannelID);
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;


function TTrunkChannel.PlayPromptStr2(AchannelID: Integer; Afilelist: string):TPlayMessageResult;
var tmpstr: string;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    if Status = csHangup then Result := pmrHangup
    else begin
      Status := csPlaying; Result := pmrPlaying;
      AchannelID := AchannelID +1;
      tmpstr := 'd'+ IntToStr(AchannelID div 10) +',d'+ IntToStr(AchannelID mod 10) +',d6,'+ Afilelist;
      HTJS_Trk_PlayPromptStr(ChannelID,tmpstr);
      HTJS_User_PlayPromptStr(AchannelID-1,tmpstr);
      HTJS_Trk_InitDtmfBuf (ChannelID);
      HTJS_User_InitDialBuf(AchannelID-1);
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.PlayFileDetect(const AllowBreak: Boolean):TPlayMessageResult;
var Aplaystop : boolean;
begin
  FChannelManager.EnterCS(D641XCS);
  try   Result := pmrPlaying;
    {$IFDEF CTI_DEBUG} ChannelLog('检测对方是否挂机'); {$ENDIF}
    if (HTJS_ISDN_GetChnState(Fpcm,Fchn) = CH_WAIT_APP_FREE) or (HTJS_ISDN_GetChnState(Fpcm,Fchn) = CH_WAIT_RELEASE) then begin// 检测对方是否挂机
      ChannelLog('对方挂机中断当前语音文件的播放'); Result := pmrHangup;
    end else begin
      Aplaystop := HTJS_Trk_CheckPlayPromptStrEnd(ChannelID);
      if Aplaystop then Result := pmrComplete
      else if AllowBreak and (HTJS_Trk_GetReciveDtmfNum(ChannelID)>0) then begin
        ChannelLog('对方按键停止当前语音文件的播放'); Result := pmrKeyPress;
      end;
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;


function TTrunkChannel.PlayFileDetect2(const AllowBreak: Boolean;AchannelID: Integer):TPlayMessageResult;
var Aplaystop,Atrunkstop,Auserstop : boolean;
begin
  FChannelManager.EnterCS(D641XCS);
  try   Result := pmrPlaying;
    {$IFDEF CTI_DEBUG} ChannelLog('检测对方是否挂机'); {$ENDIF}
    if (HTJS_ISDN_GetChnState(Fpcm,Fchn) = CH_WAIT_APP_FREE) or (HTJS_ISDN_GetChnState(Fpcm,Fchn) = CH_WAIT_RELEASE) or (HTJS_User_CheckHookOFF(AchannelID) = false) then begin// 检测对方是否挂机
      ChannelLog('双方挂机中断当前语音文件的播放'); Result := pmrHangup;
    end else begin
      //Aplaystop := HTJS_Trk_CheckPlayPromptStrEnd(ChannelID) and HTJS_User_CheckPlayPromptStrEnd(AchannelID);

      Atrunkstop := HTJS_Trk_CheckPlayPromptStrEnd(channelId);
      Auserstop :=  HTJS_User_CheckPlayPromptStrEnd(AchannelID);

      Aplaystop := Atrunkstop and Auserstop;

      if Aplaystop then Result := pmrComplete
      else if AllowBreak and (HTJS_Trk_GetReciveDtmfNum(ChannelID)>0) then begin
        ChannelLog('双方按键停止当前语音文件的播放'); Result := pmrKeyPress;
      end;
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

procedure TTrunkChannel.PlayFileStop;
begin
  FChannelManager.EnterCS(D641XCS);
  try
      HTJS_Voc_StopPlayFile(ChannelID); ChannelLog('播放语音文件结束');
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

procedure TTrunkChannel.PlayFileStop2(AchannelID: Integer);
begin
  FChannelManager.EnterCS(D641XCS);
  try
      HTJS_Voc_StopPlayFile(ChannelID);
      HTJS_User_StopPlayFile(AchannelID);
      ChannelLog('播放语音文件结束');
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.PlayFile(const Afilelist, AfileExt: string; const AllowBreak: Boolean): TPlayMessageResult;
begin
  Result := PlayPromptStr(Afilelist);
  if Result <> pmrHangup then
    while  PlayFileDetect(AllowBreak) = pmrPlaying do sleep(10);
  PlayFileStop;
end;

procedure TTrunkChannel.PlayVoice(AvoiceType: Integer);
begin
  try  
    FChannelManager.EnterCS(D641XCS);
    case AvoiceType of
      BUSY:       HTJS_Exg_SetLinkPlayVoiceToTrunk(ChannelID,SIG_BUSY);
      RINGBACK:   HTJS_Exg_SetLinkPlayVoiceToTrunk(ChannelID,SIG_RINGBACK);
      DIALTONE:   HTJS_Exg_SetLinkPlayVoiceToTrunk(ChannelID,SIG_DIALTONE);
      BACK:       HTJS_Exg_SetLinkPlayVoiceToTrunk(ChannelID,SIG_BACK);
    end;
  finally   
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.PlayFileToTrunkAndUser(const Afilelist, AfileExt: string; const AllowBreak: Boolean = True; AchannelID: Integer = -1): TPlayMessageResult; // 给双方播放音乐
begin
  try
    FChannelManager.EnterCS(D641XCS);
    HTJS_Exg_ClearLinkPlayVoiceFromTrunk(ChannelID);
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
  Result := PlayPromptStr2(AchannelID,Afilelist);
  if Result <> pmrHangup then
    while  PlayFileDetect2(AllowBreak,AchannelID) = pmrPlaying do sleep(10);
  PlayFileStop2(AchannelID);
end;

function TTrunkChannel.PlayMessage(const Atxt:string; const AllowBreak: Boolean): TPlayMessageResult;
begin
  if not Assigned(FChannelManager.TTSEngine) then
    raise Exception.Create('TTS not initialization, can not PlayMessage.');
  Result := FChannelManager.TTSEngine.PlayMessage(Self, Atxt, AllowBreak, pntMessage, VoiceResource);
end;

function TTrunkChannel.PlayNumber(const Atxt: string;
  const AllowBreak: Boolean;
  const APlayType: TPlayNumberType): TPlayMessageResult;
begin
  if not Assigned(FChannelManager.TTSEngine) then raise Exception.Create('TTS not initialization, can not PlayMessage.');
  Result := FChannelManager.TTSEngine.PlayMessage(Self, Atxt, AllowBreak, APlayType, VoiceResource);
end;

function TTrunkChannel.PlayToFile(const Atxt, Afilename: string;
  const AVoiceResource: TVoiceResourceType = vrtStandard): Boolean;
begin
  if not Assigned(FChannelManager.TTSEngine) then  raise Exception.Create('TTS not initialization, can not PlayMessage.');
  Result := FChannelManager.TTSEngine.PlayToFile(Self, Atxt, Afilename, AVoiceResource);
end;

procedure TTrunkChannel.RecordFile_stop;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    if Status = csRecording then HTJS_Voc_StopRecordFile(ChannelID);
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;
function TTrunkChannel.RecordFile(const Afilename: string;
  ALengthTimes: Integer; AllowBreak: Boolean): TRecordFileResult;
var Adir: string;
begin
  Adir := ExtractFilePath(Afilename); if not DirectoryExists(Adir) then ForceDirectories(Adir);
  FChannelManager.EnterCS(D641XCS);
  try {$IFDEF CTI_DEBUG} ChannelLog('准备进行通道录音……');{$ENDIF}
    HTJS_Voc_RecordFileNew(ChannelID,PChar(Afilename), 8000 * ALengthTimes, 0);
    Status := csRecording;
  finally
    FChannelManager.LeaveCS(D641XCS);
    Result := rfrRecording;
  end;
end;

procedure TTrunkChannel.ResetChannel;
var Ach1 : TAbstractChannel;
begin
  inherited;
  FChannelManager.EnterCS(D641XCS);
  try  ChannelLog('重置通道');
    if Status = csRecording then
     HTJS_Voc_StopRecordFile(ChannelID);
    if (FLinkToChannel <> -1) then begin
      Ach1 := TAbstractChannel(FChannelManager.truncChannels[FLinkToChannel]);
      HTJS_Trk_InitDtmfBuf(ach1.ChannelID);
      if (ach1.ChannelType = ctUser)  then HTJS_Exg_ClearLinkTrunkAndUserByTrunk(channelID);
      if (ach1.ChannelType = ctTrunk) then HTJS_Exg_ClearLinkTrunkAndTrunk(channelID);
      THackChannel(Ach1).FLinkToChannel := -1; Ach1.Status := csFree; //Ach1.Resume;
    end;

    HTJS_Trk_InitDtmfBuf(ChannelID);
    HTJS_ISDN_SetChnState(Fpcm,Fchn,CH_SET_DISCONNECT,0);
    HTJS_ISDN_SetChnState(Fpcm,Fchn,CH_SET_FREE,0);
    FLinkToChannel := -1;Status := csFree;
    if Assigned(FOnResetChannel) then FOnResetChannel(Self);     // 事件处理程序
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.RingDetect(const Atimes: Integer): Boolean;
begin
  FChannelManager.EnterCS(D641XCS);
  try  Result:=false;
    Result := HTJS_ISDN_GetChnState(Fpcm,Fchn) = CALLEE_WAIT_ANSWER;
    if result then HTJS_Trk_InitDtmfBuf(ChannelID);
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.SendMessage(const Atxt: string): Boolean;
begin
  Result := true;
end;

function TTrunkChannel.UnLink(const AChannelID: Integer; const AChannelType: TChannelType): Integer;
begin
  try
    FChannelManager.EnterCS(D641XCS);
    if HTJS_Trk_GetConnectUserID(ChannelID) <> -1 then
      HTJS_Exg_ClearLinkTrunkAndUserByTrunk(ChannelID);
    if HTJS_Trk_GetConnectTrunkID(ChannelID) <> -1 then
      HTJS_Exg_ClearLinkTrunkAndTrunk(ChannelID);
    Result := 0;
  finally   
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TTrunkChannel.UnLinkAll: Boolean;
begin
  Result := true;
end;


procedure TUserChannel.ClearDTMF;
begin
  inherited;  FDtmf := '';
  try
    {$IFDEF CTI_DEBUG} ChannelLog('DEBUG# 清除按键缓冲区中的键按信息'); {$ENDIF}
    FChannelManager.EnterCS(D641XCS);
    HTJS_User_InitDialBuf(ChannelID);
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

{-------------------------------------------------------------------------------
  Procedure: TUserChannel.ConvertDtmfToStr
  Author:    hxn
  DateTime:  2007.08.30
  Arguments: Acode: Integer
  Result:    string
  Popose:    将用户拨入的电话按键转换成字符串
-------------------------------------------------------------------------------}
function TUserChannel.ConvertDtmfToStr(Acode: Integer): string;
begin
  case Acode of
    10 : Result := '0';
    11 : Result := '*';
    12 : Result := '#';
    13 : Result := 'A';
    14 : Result := 'B';
    15 : Result := 'C';
     0 : Result := 'D';
    1..9 : Result := IntToStr(Acode);
    -1 : Result := '~';
  end;
end;

function TUserChannel.Dial(const Adialnum, APrefixnum: string): TSignalType;
begin
  try
    FChannelManager.EnterCS(D641XCS);
    Htjs_user_startring(ChannelID);
    Result := stNoResult;
  finally  
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.DtmfHit: Boolean;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    Result := HTJS_User_GetDialNum(ChannelID)>0;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.GetCalleeNumber: string;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    Result := '400 811 0006'; 
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.GetCallerNumber: string;
var
  AcallerID: PAnsiChar;   Atmp: string;
begin
  {$IFDEF CTI_DEBUG}   ChannelLog('开始获取主叫号码……');  {$ENDIF}
  Result := ''; AcallerID := StrAlloc(32 * SizeOf(Char));
  FChannelManager.EnterCS(D641XCS);
  try
    Result := Atmp; ChannelLog('获取主叫号码为：' + Result);
    if Assigned(FOnCallIn) then FOnCallIn(Self, Result);
  finally
    StrDispose(AcallerID);
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.GetDTMFCode:string;
begin
  FChannelManager.EnterCS(D641XCS);
  try Result := 'z';
    if HTJS_User_CheckHookOff(channelid) then
      begin
        Result := HTJS_User_GetDialCode(ChannelID);
        //Htjs_user_initdialbuf(channelid);
      end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.GetDTMF(const Alength: Integer; Asuffix: string;
  const Atimeout: Integer): string;
var
  K: Integer; T: Cardinal;
begin
  Result := ''; K := iif(Atimeout = 0, TimeOut, Atimeout); // 设置按键的超时值
  Status  := csGetDtmf; T := GetTickCount;
  {$IFDEF CTI_DEBUG} Log('准备获取对方按键……'); {$ENDIF}
  if Alength = -1 then begin
    while ((FDtmf = '') or (FDtmf[length(FDtmf)] <> '#')) and (GetTickCount - T < Cardinal(K * GCTimeOutRate)) do begin
      FDtmf := GetDTMFCode;
      if FDtmf = 'z' then break;
    end;
    if (FDtmf <> '') and (FDtmf[length(FDtmf)] <> '#') then FDtmf := ''
    else FDtmf := copy(FDtmf,1,length(FDtmf)-1);
    end
  else begin
    while (length(FDtmf)<Alength) and (GetTickCount - T < Cardinal(K * GCTimeOutRate)) do begin
      FDtmf := GetDTMFCode;
      if FDtmf = 'z' then break;
    end;
    if  FDtmf <> 'z' then
      if length(FDtmf)<Alength then   FDtmf := ''
      else FDtmf := copy(FDtmf,1,Alength);
  end;
  Result := FDtmf; ChannelLog('获取对方按键完成，对方按键为：' + FDtmf);
  ClearDTMF;
end;

procedure TUserChannel.HangUp;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    //tc08a32.HangUp(ChannelID);
    HTJS_User_SetPowerOFF(ChannelID);//对于用户模块停止馈电
  finally
    FChannelManager.LeaveCS(D641XCS);
    Sleep(500);
  end;
end;

function TUserChannel.HangUpDetect: Boolean;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    Result := HTJS_User_CheckHookOFF(ChannelID) = false;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.LinkTo(const AChannelID: Integer; const AChannelType: TChannelType): Integer;
var
  I, J: Integer; AfoundFlag: Boolean;Adata: Variant; T: Cardinal;
  Achnl: TUserChannel; //Adapter: TAbstractCTICardDriver;
begin Result := -1;
  try 
    FChannelManager.EnterCS(D641XCS);
    Result := -1;
    HTJS_Exg_ClearLinkPlayVoiceFromUser(ChannelID);
    if (AChannelType = ctUser) and HTJS_Exg_LinkUserAndUser(ChannelID,AChannelID) then
    begin
      HTJS_User_StopRing(AChannelID);
      Result := AChannelID; FLinkToChannel := AChannelID;
    end;
    if (AChannelType = ctTrunk) and HTJS_Exg_SetLinkTrunkAndUser(AChannelID,ChannelID) then
    begin
      Result := AChannelID; FLinkToChannel := AChannelID;
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.ListenTo(const AChannelID: Integer): Integer;
begin
    result :=0;
    //HTJS_Voc_RecordFileNew(userid,pchar(tmpstr+'\' + IntToStr(UserId+1) +'_'+ FormatDateTime('yyyymmddhhmmss',now) +'_'+ Trunk[TrunkId].CallerSubAddr + Trunk[TrunkId].CallerNumber +'.pcm'),0,20000000);
end;

procedure TUserChannel.OffHook;
//var
//  K: DWORD;
begin
  try
    FChannelManager.EnterCS(D641XCS);
    //HTJS_User_SetPowerON(ChannelID);
    htjs_exg_setlinkplayvoicetouser(channelid,SIG_DIALTONE);
    FChannelManager.LeaveCS(D641XCS);
    //K := GetTickCount; while GetTickCount - K < 500 do ;
    status := csOffHook;
    ChannelLog(GAChannelTypeLabels[ChannelType] + '通道摘机');
  except
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.OffHookDetect: Boolean;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    {$IFDEF CTI_DEBUG} ChannelLog('进行挂机检测'); {$ENDIF}
    Result := HTJS_User_CheckHookOFF(ChannelID);
    if Result then Status := csOffHook;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.PlayPromptStr(const Afilelist: string):TPlayMessageResult;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    if Status = csHangup then Result := pmrHangup
    else begin
      Status := csPlaying; Result := pmrPlaying;
      HTJS_User_PlayPromptStr(ChannelID,Afilelist);
      HTJS_User_InitDialBuf (ChannelID);
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.PlayFile(const Afilelist, AfileExt: string;
  const AllowBreak: Boolean): TPlayMessageResult;
begin
  Result := PlayPromptStr(Afilelist);
  if Result <> pmrHangup then
    while  PlayFileDetect(AllowBreak) = pmrPlaying do sleep(10);
  PlayFileStop;
end;

procedure TUserChannel.PlayVoice(AvoiceType: integer);
begin
  try  
    FChannelManager.EnterCS(D641XCS);
    case AvoiceType of
      BUSY:       HTJS_Exg_SetLinkPlayVoiceToUser(ChannelID,SIG_BUSY);
      RINGBACK:   HTJS_Exg_SetLinkPlayVoiceToUser(ChannelID,SIG_RINGBACK);
      DIALTONE:   HTJS_Exg_SetLinkPlayVoiceToUser(ChannelID,SIG_DIALTONE);
      BACK:       HTJS_Exg_SetLinkPlayVoiceToUser(ChannelID,SIG_BACK);
    end;
  finally   
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

procedure TUserChannel.PlayFileStop;
begin
  FChannelManager.EnterCS(D641XCS);
  try
      HTJS_user_StopPlayFile(ChannelID); ChannelLog('播放语音文件结束');
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.PlayFileDetect(const AllowBreak: Boolean):TPlayMessageResult;
var Aplaystop : boolean;
begin
  FChannelManager.EnterCS(D641XCS);
  try   Result := pmrPlaying;
    {$IFDEF CTI_DEBUG} ChannelLog('检测对方是否挂机'); {$ENDIF}
    if htjs_user_checkhookoff(ChannelID) = false then begin// 检测对方是否挂机
      ChannelLog('对方挂机中断当前语音文件的播放'); Result := pmrHangup;
    end else begin
      Aplaystop := HTJS_user_CheckPlayPromptStrEnd(ChannelID);
      if Aplaystop then Result := pmrComplete
      else if AllowBreak and (HTJS_User_GetDialNum(ChannelID)>0) then begin
        ChannelLog('对方按键停止当前语音文件的播放'); Result := pmrKeyPress;
      end;
    end;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.PlayMessage(const Atxt:string; const AllowBreak: Boolean): TPlayMessageResult;
begin
  if not Assigned(FChannelManager.TTSEngine) then
    raise Exception.Create('TTS not initialization, can not PlayMessage.');
  Result := FChannelManager.TTSEngine.PlayMessage(Self, Atxt, AllowBreak, pntMessage, VoiceResource);
end;

function TUserChannel.PlayNumber(const Atxt: string;
  const AllowBreak: Boolean;
  const APlayType: TPlayNumberType): TPlayMessageResult;
begin
  if not Assigned(FChannelManager.TTSEngine) then raise Exception.Create('TTS not initialization, can not PlayMessage.');
  Result := FChannelManager.TTSEngine.PlayMessage(Self, Atxt, AllowBreak, APlayType, VoiceResource);
end;

function TUserChannel.PlayToFile(const Atxt, Afilename: string;
  const AVoiceResource: TVoiceResourceType = vrtStandard): Boolean;
begin
  if not Assigned(FChannelManager.TTSEngine) then  raise Exception.Create('TTS not initialization, can not PlayMessage.');
  Result := FChannelManager.TTSEngine.PlayToFile(Self, Atxt, Afilename, AVoiceResource);
end;


function TUserChannel.RecordFile(const Afilename: string;
  ALengthTimes: Integer; AllowBreak: Boolean): TRecordFileResult;
var Adir: string;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    // 检查文件路径是否有效
    Adir := ExtractFilePath(Afilename);
    if not DirectoryExists(Adir) then ForceDirectories(Adir);

    if Status = csPlaying then
    begin
      // if FAttachTTS then HTJS_TTS3_StopPlayText(ChannelID);

      //StopIndexPlayFile(ChannelID);
      
      if channeltype = ctTrunk then
        HTJS_Voc_StopIndexPlayFile(ChannelID)
      else
        HTJS_User_StopPlayFile(ChannelID);

    end;
    {$IFDEF CTI_DEBUG}
    ChannelLog('准备进行通道录音……');
    {$ENDIF}

    // 开始进行录音
    if channeltype = ctTrunk then
      HTJS_Trk_InitDtmfBuf(ChannelID)
    else
      HTJS_User_InitDialBuf(ChannelID);
      
    Status := csRecording;
    //StartRecordFileNew(ChannelID, PChar(Afilename), 8000 * ALengthTimes, 0);
    HTJS_Voc_RecordFileNew(ChannelID,PChar(Afilename), 8000 * ALengthTimes, 0);

    //StartSigCheck(ChannelID);

    //while not CheckRecordEnd(ChannelID) do
    //begin
      //PUSH_PLAY();
      HTJS_ISDN_GetEvent;
      HTJS_Sys_PushPlay;
      {$IFDEF CTI_DEBUG}
      ChannelLog('检测录音过程中是否有按键操作');
      {$ENDIF}

      // 在录音的过程中对方按键
      if channeltype = ctTrunk then
        begin
          if AllowBreak and (HTJS_Trk_GetReciveDtmfNum(ChannelID) > 0) then
            begin
              ChannelLog('对方按键中断了当前通道录音过程');
              Status := csGetDtmf;
              //StopRecordFile(ChannelID);
              HTJS_Voc_StopRecordFile(ChannelID);
              Result := rfrKeyPress;
              Exit;
            end
        end
      else
        begin
          if AllowBreak and (HTJS_User_GetDialNum(ChannelID) > 0) then
            begin   
              ChannelLog('对方按键中断了当前通道录音过程');
              Status := csGetDtmf;
              //StopRecordFile(ChannelID);
              HTJS_User_StopRecordFile(ChannelID);
              Result := rfrKeyPress;
              Exit;
            end
        end;

      {if AllowBreak and tc08a32.DtmfHit(ChannelID) then
      begin
        ChannelLog('对方按键中断了当前通道录音过程');
        Status := csGetDtmf;
        StopRecordFile(ChannelID);
        Result := rfrKeyPress;
        Exit;
      end;}

      {$IFDEF CTI_DEBUG}
      ChannelLog('检测录音过程中对方是否挂机');
      {$ENDIF}
      // 在录音的过程中对方挂机
      if HangUpDetect() then
      begin
        ChannelLog('对方挂机中断了当前通道录音过程');
        Status := csHangUp;

        //StopRecordFile(ChannelID);
        if channeltype = ctTrunk then
          HTJS_Voc_StopRecordFile(ChannelID)
        else
          HTJS_User_StopRecordFile(ChannelID);
        Result := rfrHangup;
        Exit;
      end;
    //end;

    ChannelLog('完成通道录音，录音文件为：' + Afilename);

    //StopRecordFile(ChannelID);
    if channeltype = ctTrunk then
      HTJS_Voc_StopRecordFile(ChannelID)
    else
      HTJS_User_StopRecordFile(ChannelID);

    Result := rfrComplete;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

procedure TUserChannel.ResetChannel;
var Ach1 : TAbstractChannel;
begin
  inherited;
  FChannelManager.EnterCS(D641XCS);
  try  ChannelLog('重置通道');
    if (FLinkToChannel <> -1) then begin
      Ach1 := TAbstractChannel(FChannelManager.userChannels[FLinkToChannel]);
      
      HTJS_Trk_InitDtmfBuf(ach1.ChannelID);
      HTJS_Exg_ClearLinkUserAndUser(channelID);
      HTJS_Exg_ClearLinkTrunkAndUserByTrunk(Ach1.ChannelID);
      HTJS_Exg_ClearLinkTrunkAndUserByUser(channelID);
      THackChannel(Ach1).FLinkToChannel := -1; Ach1.Status := csFree;
    end;
    FLinkToChannel := -1;

    if HTJS_User_RingDetect(ChannelID) then HTJS_User_StopRing(ChannelID);
    if HTJS_User_GetPlayChannel(ChannelID)<> -1 then
      begin
        HTJS_User_StopPlayFile(ChannelID);
        HTJS_Exg_ClearLinkPlayVoiceFromUser(ChannelID)
      end;
    if HTJS_User_GetListenUserID(ChannelID)<> -1 then HTJS_Exg_ClearListenUserFromUser(ChannelID);
    if HTJS_User_GetListenTrunkID(ChannelID)<> -1 then HTJS_Exg_ClearListenUserFromTrunk(ChannelID);
    
    HTJS_User_InitDialBuf(ChannelID);
    HTJS_User_SetPowerON(ChannelID);
    Status := csFree;
    if Assigned(FOnResetChannel) then FOnResetChannel(Self);     // 事件处理程序
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.RingDetect(const Atimes: Integer): Boolean;
const RingbackRate = 4000;
var   N: Integer; T: Cardinal;
begin  result:=false;
  try
    N := Atimes; if N < 0 then N := 0;  T := GetTickCount+10;
    while not result and (GetTickCount - T < N * RingBackRate) do begin
      FChannelManager.EnterCS(D641XCS);
      Result :=  HTJS_User_RingDetect(ChannelID);
      FChannelManager.LeaveCS(D641XCS);
    end;
    if result then if channeltype = ctTrunk then  HTJS_Trk_InitDtmfBuf(ChannelID) else HTJS_User_InitDialBuf(ChannelID);
  except
  end;
end;

function TUserChannel.SendMessage(const Atxt: string): Boolean;
begin
   Result :=  false;
end;

function TUserChannel.UnLink(const AChannelID: Integer; const AChannelType: TChannelType): Integer;
begin
  try
    FChannelManager.EnterCS(D641XCS);
    if HTJS_User_GetConnectTrunkID(ChannelID) <> -1 then
      HTJS_Exg_ClearLinkTrunkAndUserByUser(ChannelID);
    if HTJS_User_GetConnectUserID(ChannelID) <> -1 then
      HTJS_Exg_ClearLinkUserAndUser(ChannelID);
    Result := 0;
  finally   
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

function TUserChannel.UnLinkAll: Boolean;
begin
   Result :=  false;
end;

function TUserChannel.Schedule(AserverType: string ;Afilelist: string): Integer;//获取最少接电话的坐席号
var
  AchannelID :integer;
begin
  FChannelManager.EnterCS(D641XCS);
  try
    AchannelID := -1;
    Result := AchannelID;
  finally
    FChannelManager.LeaveCS(D641XCS);
  end;
end;

end.
